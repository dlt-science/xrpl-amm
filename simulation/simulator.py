# TODO: FIX style/code pres.

import random
from typing import Any, Union, List

# from collections.abc import Iterable
from amms.xrpl.amm.actions import Swap, Deposit, AMMBid
from amms.xrpl.amm.env import User, AMMi
from amms.uniswap.uniswap import Uniswap_amm
from simulation.process_txs import ProcessTransactions
from simulation.simulator_computations import SimulatorComputations
import numpy as np
import itertools


class Simulator(SimulatorComputations, ProcessTransactions):
    def simulate_normal_users_txs(
        self,
        amm,
        current_block,
        time_step: int,
        action,
        amount,
        sp,
        sp_B=None,
        swapper=None,
    ) -> list:
        if action == "pass":
            return current_block

        swapper = swapper or amm
        if isinstance(amm, AMMi):
            asset_in, asset_out = ("B", "A") if action == "buy" else ("A", "B")
            multiplier = 1 if action == "buy" else sp

            current_block.append(
                {
                    "time_step": time_step,
                    "tx_type": f"normal_user_{action}",
                    "process_tx": lambda: swapper.swap_given_amount_Out(
                        assetIn=asset_in,
                        assetOut=asset_out,
                        amount_out=amount * multiplier,
                    ),
                }
            )

        elif isinstance(amm, Uniswap_amm):
            asset = "A" if action == "buy" else "B"
            multiplier = 1 if action == "buy" else sp
            current_block.append(
                {
                    "time_step": time_step,
                    "tx_type": f"normal_user_{action}",
                    "process_tx": lambda: swapper.swap(
                        asset, amount * multiplier, sp_B
                    ),
                }
            )

        return current_block

    def populate_xrpl_arbs(self, num_arbs: int, amm: AMMi, is_xrplCAM: bool):
        """Create arbitrageurs in the specified AMM.

        Args:
            num_arbs (int): Number of arbitrageurs to create.
            amm (obj): The XRPL AMM instance to add arbitrageurs.
                Class object of AMMi class.
            is_xrplCAM (bool): True if the XRPL AMM is with CAM

        Returns:
            tuple: List of objects to populate the AMM with arbitrageurs.
        """

        users_obj = []
        for i in range(1, num_arbs + 1):
            username = f"xrplCAM_arbit{i}" if is_xrplCAM else f"xrpl_arbit{i}"
            user_assets = {"XRP": 1000, "A": 1e450, "B": 1e450}
            users_obj.append(User(username, user_assets))

        bids_obj = []
        deposits_obj = []
        swaps_obj = []
        for user in users_obj:
            bids_obj.append(AMMBid(user, amm)) if is_xrplCAM else None
            deposits_obj.append(Deposit(user, amm))
            swaps_obj.append(Swap(user, amm))

        if is_xrplCAM:
            return deposits_obj, swaps_obj, bids_obj
        return swaps_obj

    def check_arbit_opportunity(
        self,
        time_step: int,
        amm: type[AMMi | Uniswap_amm],
        current_block: List[dict],
        external_price: float,
        network_fees: float,
        safe_profit_margin: float,
        swapper: Swap = None,
    ) -> List[dict]:
        """Check if there is a profit-making opportunity through arbitrage.

        Check for any arbitrage opportunity by either buying or selling A.
        If potential profits > safe profit margin, then place transaction.

        Example:
        If A is cheaper on AMM than external market, the arbitrageur will first
        check if the potential profits generated by buying A on AMM and selling
        external market is greater than the safe profit margin. If it is,
        on the trade is placed and added to the block.

        Args:
            time-step (int): Time-step when transaction was placed.
            amm (obj): The AMM instance to check the balance in.
                Class object of either AMMi (for XRPL AMM) or Uniswap_amm classes.
            current_block (list): Block containing all transactions to be processed.
            external_price (float): Current external market price of asset A.
            network_fees (float): AMM network fees.
            safe_profit_margin (float): Arbitrageur's minimum profit margin accepted.
            swapper (obj; Optional: None): The arbitrageur's swap object to perform swaps.
                Class object of the Swap class (for XRPL AMM).
                This is necessary only because of the distinct coding approaches used for the XRPL AMM and Uniswap classes.

        Returns:
            list: Updated current_block list.
        """

        discounted_fee = (
            True
            if isinstance(amm, AMMi) and amm.AuctionSlot["slot_owner"] == swapper.user
            else False
        )
        swapper = swapper or amm

        # sell A
        if amm.spot_price("B", "A", discounted_fee) < 1 / external_price:
            amount_in, amount_out = swapper.swap_given_postSP(
                assetIn="A",
                assetOut="B",
                balAssetIn=self.get_balAsset(amm, "A"),
                balAssetOut=self.get_balAsset(amm, "B"),
                pre_sp=amm.spot_price("B", "A", discounted_fee),
                post_sp=1 / external_price,
                skip_pool_update=True,
            )[0:2]
            potential_profits = (
                amount_out / external_price - amount_in
            ) - network_fees * amm.spot_price(
                "B", "A"
            )  # in units of A
            if potential_profits / amount_in > safe_profit_margin:
                current_block.append(
                    {
                        "time_step": time_step,
                        "external_market_price": 1 / external_price,
                        "amm_price": amm.spot_price("B", "A"),
                        "tx_type": "sell",
                        "amount_in": amount_in,
                        "process_tx": lambda post_sp, amount_in, skip_pool_update=False: swapper.swap_given_postSP(
                            assetIn="A",
                            assetOut="B",
                            balAssetIn=self.get_balAsset(amm, "A"),
                            balAssetOut=self.get_balAsset(amm, "B"),
                            pre_sp=amm.spot_price("B", "A", discounted_fee),
                            post_sp=post_sp,
                            amount_in=amount_in,
                            skip_pool_update=skip_pool_update,
                        ),
                    }
                )
        # buy A
        if amm.spot_price("A", "B", discounted_fee) < external_price:
            amount_in, amount_out = swapper.swap_given_postSP(
                assetIn="B",
                assetOut="A",
                balAssetIn=self.get_balAsset(amm, "B"),
                balAssetOut=self.get_balAsset(amm, "A"),
                pre_sp=amm.spot_price("A", "B", discounted_fee),
                post_sp=external_price,
                skip_pool_update=True,
            )[0:2]
            potential_profits = (amount_out * external_price - amount_in) - network_fees
            if amount_in and potential_profits / amount_in > safe_profit_margin:
                current_block.append(
                    {
                        "time_step": time_step,
                        "external_market_price": external_price,
                        "amm_price": amm.spot_price("A", "B"),
                        "tx_type": "buy",
                        "amount_in": amount_in,
                        "process_tx": lambda post_sp, amount_in, skip_pool_update=False: swapper.swap_given_postSP(
                            assetIn="B",
                            assetOut="A",
                            balAssetIn=self.get_balAsset(amm, "B"),
                            balAssetOut=self.get_balAsset(amm, "A"),
                            pre_sp=amm.spot_price("A", "B", discounted_fee),
                            post_sp=post_sp,
                            amount_in=amount_in,
                            skip_pool_update=skip_pool_update,
                        ),
                    }
                )

        return current_block

    def bid_strategy(
        self,
        max_bid,
        amm,
        slot_time_interval,
        swapper,
        bidder,
        external_price,
        safe_profit_margin,
        network_fees,
    ):
        discounted_fee = True
        minBidPrice = self.compute_minimum_bid_price(amm, slot_time_interval)

        if amm.spot_price("B", "A", discounted_fee) < 1 / external_price:
            # amount_in, amount_out = swapper.swap_given_postSP(
            #     assetIn="A",
            #     assetOut="B",
            #     balAssetIn=self.get_balAsset(amm, "A"),
            #     balAssetOut=self.get_balAsset(amm, "B"),
            #     pre_sp=amm.spot_price("B", "A", discounted_fee),
            #     post_sp=1 / external_price,
            #     skip_pool_update=True,
            # )[0:2]
            # potential_profits = (
            #     amount_out / external_price - amount_in
            # ) - network_fees / amm.spot_price(
            #     "A", "B", discounted_fee
            # )  # in A

            # LPToken_price_in_A = self.LPT_price(
            #     amm.assets["LPTokens"],
            #     amm.assets["A"],
            #     amm.assets["B"],
            #     1,
            #     amm.spot_price("B", "A"),
            # )

            # bid = potential_profits / LPToken_price_in_A * 0.2
            # refund = (1 - slot_time_interval + 0.05) * bid
            # bid += refund

            bidPrice = bidder.bid(
                slot_time_interval,
                min_price=minBidPrice,
                max_price=None,
                skip_pool_update=True,
            )[0]
            if (
                bidPrice
                and bidPrice
                * self.LPT_price(
                    amm.assets["LPTokens"],
                    amm.assets["A"],
                    amm.assets["B"],
                    amm.spot_price("A", "B"),
                    1,
                )
                < max_bid
            ):
                return bidPrice

        if amm.spot_price("A", "B", discounted_fee) < external_price:
            # amount_in, amount_out = swapper.swap_given_postSP(
            #     assetIn="B",
            #     assetOut="A",
            #     balAssetIn=self.get_balAsset(amm, "B"),
            #     balAssetOut=self.get_balAsset(amm, "A"),
            #     pre_sp=amm.spot_price("A", "B", discounted_fee),
            #     post_sp=external_price,
            #     skip_pool_update=True,
            # )[0:2]
            # potential_profits = (amount_out * external_price - network_fees) - amount_in

            LPToken_price_in_B = self.LPT_price(
                amm.assets["LPTokens"],
                amm.assets["A"],
                amm.assets["B"],
                amm.spot_price("A", "B"),
                1,
            )

            # bid = potential_profits * 0.2 / LPToken_price_in_B
            # refund = (1 - slot_time_interval + 0.05) * bid

            # bid += refund

            bidPrice = bidder.bid(
                slot_time_interval,
                min_price=minBidPrice,
                max_price=None,
                skip_pool_update=True,
            )[0]

            if bidPrice and bidPrice * LPToken_price_in_B < max_bid:
                return bidPrice

    def check_bid(
        self,
        max_bid,
        time_step: int,
        slot_time_interval: float,
        amm: AMMi,
        current_block: List[dict],
        external_price: float,
        network_fees: float,
        swapper: Swap,
        bidder: AMMBid,
        safe_profit_margin: float,
        ii,
        worst_case=False,
    ) -> List[dict]:
        # if current bidder is slot owner, do not bid
        if bidder.user == amm.AuctionSlot["slot_owner"]:
            return current_block

        minBidPrice = self.compute_minimum_bid_price(amm, slot_time_interval)

        if (
            worst_case
            and slot_time_interval == 0.05
            and not amm.AuctionSlot["slot_owner"]
        ):
            current_block.append(
                {
                    "time_step": time_step,
                    "tx_type": "bid",
                    "process_tx": lambda skip_pool_update: bidder.bid(
                        slot_time_interval,
                        min_price=minBidPrice,
                        max_price=None,
                        skip_pool_update=skip_pool_update,
                    ),
                }
            )
            return current_block

        #                                       -------------------- KEEP FOR WORSE 2ND CASE --------------------
        # if worst_case and (slot_time_interval == 0.5 or not amm.AuctionSlot['slot_owner']):
        #     # print(slot_time_interval, s)
        #     # print('ownnerr', amm.AuctionSlot['slot_owner'])
        #     current_block.append({
        #         'time_step': time_step,
        #         'tx_type': 'bid',
        #         'process_tx': lambda skip_pool_update: bidder.bid(
        #             slot_time_interval, min_price=minBidPrice, max_price=None, skip_pool_update=skip_pool_update)})
        #     return current_block

        elif not worst_case:
            if time_step:
                bidPrice = self.bid_strategy(
                    max_bid,
                    amm,
                    slot_time_interval,
                    swapper,
                    bidder,
                    external_price,
                    safe_profit_margin,
                    network_fees,
                )

                if bidPrice:
                    current_block.append(
                        {
                            "time_step": time_step,
                            "tx_type": "bid",
                            "process_tx": lambda skip_pool_update: bidder.bid(
                                slot_time_interval,
                                min_price=None,
                                max_price=bidPrice,
                                skip_pool_update=skip_pool_update,
                            ),
                        }
                    )

        return current_block

    def run_simulation(
        self,
        initial_A_price: float,
        external_prices_full: list,
        xrpl_block_conf: int,
        eth_block_conf: int,
        xrpl_fees: float,
        eth_fees: float,
        tfee_rate: float,
        normal_users: int,
        arbitrageurs: int,
        safe_profit_margin: float,
        max_slippage: float,
        iterations: int,
        one_day: int,
        start_simulation_at_day: int,
        worst_case: bool,
        with_cases: bool,
    ):
        """Simulate XRPL & Uniswap AMMs with a reference market.

        Args:
            initial_A_price (float): AMM Asset A price we wish the simulation to begin with.
                Should be equal to the initial external market price.
            external_prices (list): Number of normal user transactions to simulate.
            xrpl_block_conf (int): XRPL block confirmation time.
            eth_block_conf (int): Ethereum block confirmation time.
            xrpl_fees (float): XRPL network fees.
            eth_fees (float): Ethereum network fees.
            tfee_rate (float): AMMs trading fee.
            normal_users (int): Number of normal users to simulate.
            arbitrageurs (int): Number of arbitrageurs to simulate.
            safe_profit_margin (float): Arbitrageur's minimum profit margin accepted.
            max_slippage (float): The maximum slippage tolerated.
            iterations (int): Number of times to run the simulation with the same parameters.
                Each iteration is independent of the previous one.

            one_day (int):
            start_simulation_at_day (int):
            worst_case (bool):
            with_cases (bool): True if running the simulation with worst and best case scenarios.
                If True, variables with "xrpl_..." relate to the XRPL AMM with CAM worst-case for LPs (XRPL-CAM-B).
                If False, variables with "xrpl_..." relate to the XRPL AMM without CAM.

        Returns:
            dict: Check return statement.
            TODO: update docs
        """

        initial_A_reserve = 50_000
        initial_B_reserve = self.compute_initial_B_reserve(
            initial_A_price, initial_A_reserve, tfee_rate
        )

        xrpls_CAM_ArbProfits_advantage = 0
        xrpls_CAM_PriceGap_advantage = 0
        xrpls_CAM_LP_returns_advantage = 0

        # INITIALIZE XRPLCAM
        xrplCAM_profits_total = []
        xrplCAM_arbit_txs_total = []
        xrplCAM_ArbProfits_advantage = 0
        xrplCAM_PriceGap_advantage = 0
        xrplCAM_LP_returns_advantage = 0
        xrplCAM_slippages_total = []
        xrplCAM_unrealized_tx_total = []
        auction_slot_price_total = []
        xrplCAM_sps_total = []
        xrplCAM_tfees_total = []
        slot_holders_txs = []
        bids_profit_total = []
        xrplCAM_trading_volumes = []
        bids_refunds_total = []

        # INITIALIZE XRPL
        xrpl_profits_total = []
        xrpl_arbit_txs_total = []
        xrpl_ArbProfits_advantage = 0
        xrpl_PriceGap_advantage = 0
        xrpl_LP_returns_advantage = 0
        xrpl_slippages_total = []
        xrpl_unrealized_tx_total = []
        xrpl_sps_total = []
        xrpl_tfees_total = []
        xrpl_trading_volumes = []
        # for if with_cases:
        xrpl_bids_refunds_total = []
        xrpl_slot_holders_txs = []
        xrpl_bids_profit_total = []
        xrpl_auction_slot_price_total = []

        # INITIALIZE UNISWAP
        uniswap_profits_total = []
        uniswap_arbit_txs_total = []
        uniswap_slippages_total = []
        uniswap_unrealized_tx_total = []
        uniswap_sps_total = []
        uniswap_tfees_total = []
        uniswap_trading_volumes = []

        impermanent_losses = {"xrplCAM": [], "xrpl": [], "uniswap": []}
        price_impacts = {"xrplCAM": [], "xrpl": [], "uniswap": []}

        sub_ext_prices = external_prices_full[: one_day * start_simulation_at_day + 1]
        one_interval_duration = one_day / 20

        print("Simmulation running...")

        for iteration in range(iterations):
            """
            At each iteration, we set the users and AMMs statuses to their initial one and re-run the simulation.
            Each iteration is independent of the previous one.
            """

            slot_time_intervals = [
                round(n, 2)
                for n in np.linspace(0.05, 1, 20)
                for _ in range(int(one_interval_duration))
            ]

            # bob = normal user on xrpl
            bob = User(user_name="bob", assets={"XRP": 1000, "A": 1e450, "B": 1e450})
            bobCAM = User(
                user_name="bobCAM", assets={"XRP": 1000, "A": 1e450, "B": 1e450}
            )

            # xrpl_amm = bob.createAMM(
            #     ammID=1,
            #     asset1="A",
            #     asset2="B",
            #     amount1=initial_A_reserve,
            #     amount2=initial_B_reserve,
            #     TFee=tfee_rate,
            # )

            if with_cases:
                xrpl_amm = bob.createAMM(
                    ammID=1,
                    asset1="A",
                    asset2="B",
                    amount1=initial_A_reserve / (arbitrageurs + 1),
                    amount2=initial_B_reserve / (arbitrageurs + 1),
                    TFee=tfee_rate,
                )

                (
                    xrpl_arbits_deposits_obj,
                    xrpl_arbits_swaps_obj,
                    xrpl_arbits_bids_obj,
                ) = self.populate_xrpl_arbs(arbitrageurs, xrpl_amm, is_xrplCAM=True)

                for arbit in xrpl_arbits_deposits_obj:
                    Deposit(arbit.user, xrpl_amm).deposit_Amount1_Amount2(
                        "A",
                        "B",
                        initial_A_reserve / (arbitrageurs + 1),
                        initial_B_reserve / (arbitrageurs + 1),
                    )
            else:
                xrpl_amm = bob.createAMM(
                    ammID=1,
                    asset1="A",
                    asset2="B",
                    amount1=initial_A_reserve,
                    amount2=initial_B_reserve,
                    TFee=tfee_rate,
                )
                xrpl_arbits_swaps_obj = self.populate_xrpl_arbs(
                    arbitrageurs, xrpl_amm, is_xrplCAM=False
                )

            xrplCAM = bobCAM.createAMM(
                ammID=2,
                asset1="A",
                asset2="B",
                amount1=initial_A_reserve / (arbitrageurs + 1),
                amount2=initial_B_reserve / (arbitrageurs + 1),
                TFee=tfee_rate,
            )

            (
                xrplCAM_arbits_deposits_obj,
                xrplCAM_arbits_swaps_obj,
                xrplCAM_arbits_bids_obj,
            ) = self.populate_xrpl_arbs(arbitrageurs, xrplCAM, is_xrplCAM=True)

            for arbit in xrplCAM_arbits_deposits_obj:
                Deposit(arbit.user, xrplCAM).deposit_Amount1_Amount2(
                    "A",
                    "B",
                    initial_A_reserve / (arbitrageurs + 1),
                    initial_B_reserve / (arbitrageurs + 1),
                )

            # initiate both bob and arbit swap objects on xrpl in order to let them make swaps
            bob_swaps = Swap(bob, xrpl_amm)
            bobCAM_swaps = Swap(bobCAM, xrplCAM)

            # uniswap AMM
            uniswap_amm = Uniswap_amm(
                tfee_rate,
                asset_A_amount=initial_A_reserve,
                asset_B_amount=initial_B_reserve,
                initial_LP_token_number=1000,
            )

            # INITIATE XRPLCAM
            current_xrplCAM_block = []
            xrplCAM_profits = []
            xrplCAM_arbit_txs = 0
            xrplCAM_sps = []
            xrplCAM_sps_B = []
            xrplCAM_slippages = []
            xrplCAM_unrealized_tx = 0
            auction_slot_price = []
            xrplCAM_tfees = 0
            bids_profit = {"LPTokens": 0, "B": 0}
            current_slot_holders_txs = 0
            xrplCAM_current_trading_volume = 0
            bids_refunds = {"LPTokens": 0, "A": 0, "B": 0}
            new_24h_start = 0
            iter = itertools.cycle(slot_time_intervals)

            # INITIATE XRPL
            current_xrpl_block = []
            xrpl_profits = []
            xrpl_arbit_txs = 0
            xrpl_sps = []
            xrpl_sps_B = []
            xrpl_slippages = []
            xrpl_unrealized_tx = 0
            xrpl_auction_slot_price = []
            xrpl_tfees = 0
            xrpl_bids_profit = {"LPTokens": 0, "B": 0}
            xrpl_current_slot_holders_txs = 0
            xrpl_current_trading_volume = 0
            xrpl_bids_refunds = {"LPTokens": 0, "A": 0, "B": 0}
            xrpl_new_24h_start = 0
            xrpl_iter = itertools.cycle(slot_time_intervals)

            # INITIATE UNISWAP
            current_uniswap_block = []
            uniswap_profits = []
            uniswap_arbit_txs = 0
            uniswap_sps = []
            uniswap_sps_B = []
            uniswap_slippages = []
            uniswap_unrealized_tx = 0
            uniswap_tfees = 0
            uniswap_current_trading_volume = 0

            action = random.choice(["buy", "sell"])

            # xrplCAM_initial_B_price = xrplCAM.spot_price("B", "A")
            # xrpl_initial_B_price = xrpl_amm.spot_price("B", "A")
            # uniswap_initial_B_price = uniswap_amm.spot_price("B", "A")

            xrplCAM_0fee_profits_total = (
                self.estimate_profits(
                    initial_A_reserve,
                    tfee_rate,
                    sub_ext_prices,
                    xrpl_block_conf,
                    xrpl_fees,
                    max_slippage,
                    safe_profit_margin,
                    one_day,
                    normal_users,
                )
                if not worst_case or start_simulation_at_day > 0
                else None
            )

            max_bid = (
                np.average(
                    xrplCAM_0fee_profits_total,
                    weights=[
                        0.5**i
                        for i in reversed(range(len(xrplCAM_0fee_profits_total)))
                    ],
                )
                if xrplCAM_0fee_profits_total
                else 10000
            )

            external_prices = external_prices_full[one_day * start_simulation_at_day :]

            for time_step in range(len(external_prices)):
                if not xrplCAM.AuctionSlot["slot_owner"]:
                    iter = itertools.cycle(slot_time_intervals)
                    current_slot_time_interval = next(iter)
                else:
                    current_slot_time_interval = next(iter)

                if not xrpl_amm.AuctionSlot["slot_owner"]:
                    xrpl_iter = itertools.cycle(slot_time_intervals)
                    xrpl_current_slot_time_interval = next(xrpl_iter)
                else:
                    xrpl_current_slot_time_interval = next(xrpl_iter)

                # UPDATE XRPL POOLs
                if time_step % xrpl_block_conf == 0:
                    (
                        xrplCAM_sp,
                        xrplCAM_sp_B,
                        xrplCAM_profits,
                        xrplCAM_arbit_txs,
                        current_xrplCAM_block,
                        xrplCAM_slippages,
                        xrplCAM_unrealized_tx,
                        xrplCAM_tfees,
                        xrplCAM_current_trading_volume,
                        price_impacts["xrplCAM"],
                        bid_won,
                        auction_slot_price,
                        current_slot_holders_txs,
                        bids_profit,
                        bids_refunds,
                    ) = self.process_all_txs(
                        time_step,
                        xrplCAM,
                        current_xrplCAM_block,
                        max_slippage,
                        external_prices,
                        xrpl_fees,
                        xrplCAM_profits,
                        xrplCAM_arbit_txs,
                        xrplCAM_slippages,
                        xrplCAM_unrealized_tx,
                        xrplCAM_tfees,
                        xrplCAM_current_trading_volume,
                        price_impacts["xrplCAM"],
                        auction_slot_price,
                        current_slot_holders_txs,
                        bids_profit,
                        bids_refunds,
                    )
                    if bid_won:
                        iter = itertools.cycle(slot_time_intervals)
                        current_slot_time_interval = next(iter)
                        new_24h_start = time_step

                    # elif not bid_won and current_slot_time_interval == 1 and count_interval_1 == one_interval_duration:
                    elif (
                        not bid_won
                        and current_slot_time_interval == 1
                        and time_step == new_24h_start + one_day
                    ):
                        iter = itertools.cycle(slot_time_intervals)
                        current_slot_time_interval = next(iter)
                        xrplCAM.AuctionSlot["slot_owner"] = None

                    if with_cases:
                        (
                            xrpl_sp,
                            xrpl_sp_B,
                            xrpl_profits,
                            xrpl_arbit_txs,
                            current_xrpl_block,
                            xrpl_slippages,
                            xrpl_unrealized_tx,
                            xrpl_tfees,
                            xrpl_current_trading_volume,
                            price_impacts["xrpl"],
                            xrpl_bid_won,
                            xrpl_auction_slot_price,
                            xrpl_current_slot_holders_txs,
                            xrpl_bids_profit,
                            xrpl_bids_refunds,
                        ) = self.process_all_txs(
                            time_step,
                            xrpl_amm,
                            current_xrpl_block,
                            max_slippage,
                            external_prices,
                            xrpl_fees,
                            xrpl_profits,
                            xrpl_arbit_txs,
                            xrpl_slippages,
                            xrpl_unrealized_tx,
                            xrpl_tfees,
                            xrpl_current_trading_volume,
                            price_impacts["xrpl"],
                            xrpl_auction_slot_price,
                            xrpl_current_slot_holders_txs,
                            xrpl_bids_profit,
                            xrpl_bids_refunds,
                        )
                        if xrpl_bid_won:
                            xrpl_iter = itertools.cycle(slot_time_intervals)
                            xrpl_current_slot_time_interval = next(xrpl_iter)
                            xrpl_new_24h_start = time_step
                        # elif not bid_won and current_slot_time_interval == 1 and count_interval_1 == one_interval_duration:
                        elif (
                            not xrpl_bid_won
                            and xrpl_current_slot_time_interval == 1
                            and time_step == xrpl_new_24h_start + one_day
                        ):
                            xrpl_iter = itertools.cycle(slot_time_intervals)
                            xrpl_current_slot_time_interval = next(xrpl_iter)
                            xrpl_amm.AuctionSlot["slot_owner"] = None
                    else:
                        (
                            xrpl_sp,
                            xrpl_sp_B,
                            xrpl_profits,
                            xrpl_arbit_txs,
                            current_xrpl_block,
                            xrpl_slippages,
                            xrpl_unrealized_tx,
                            xrpl_tfees,
                            xrpl_current_trading_volume,
                            price_impacts["xrpl"],
                        ) = self.process_all_txs(
                            time_step,
                            xrpl_amm,
                            current_xrpl_block,
                            max_slippage,
                            external_prices,
                            xrpl_fees,
                            xrpl_profits,
                            xrpl_arbit_txs,
                            xrpl_slippages,
                            xrpl_unrealized_tx,
                            xrpl_tfees,
                            xrpl_current_trading_volume,
                            price_impacts["xrpl"],
                        )[
                            0:10
                        ]

                # UPDATE UNISWAP POOL
                if time_step % eth_block_conf == 0:
                    (
                        uniswap_sp,
                        uniswap_sp_B,
                        uniswap_profits,
                        uniswap_arbit_txs,
                        current_uniswap_block,
                        uniswap_slippages,
                        uniswap_unrealized_tx,
                        uniswap_tfees,
                        uniswap_current_trading_volume,
                        price_impacts["uniswap"],
                    ) = self.process_all_txs(
                        time_step,
                        uniswap_amm,
                        current_uniswap_block,
                        max_slippage,
                        external_prices,
                        eth_fees,
                        uniswap_profits,
                        uniswap_arbit_txs,
                        uniswap_slippages,
                        uniswap_unrealized_tx,
                        uniswap_tfees,
                        uniswap_current_trading_volume,
                        price_impacts["uniswap"],
                    )[
                        0:10
                    ]
                # keep track of the price evolutions on xrpl-amm and uniswap
                xrpl_sps.append(xrpl_sp)
                xrpl_sps_B.append(xrpl_sp_B)

                xrplCAM_sps.append(xrplCAM_sp)
                xrplCAM_sps_B.append(xrplCAM_sp_B)

                uniswap_sps.append(uniswap_sp)
                uniswap_sps_B.append(uniswap_sp_B)

                # NORMAL USERS TRANSACTIONS
                # simulate normal users placing transactions
                for _ in range(normal_users):
                    action = self.normal_user_action(action)
                    amount = random.uniform(0.01, 2)
                    current_xrplCAM_block = self.simulate_normal_users_txs(
                        xrplCAM,
                        current_xrplCAM_block,
                        time_step,
                        action,
                        amount,
                        xrplCAM_sp,
                        swapper=bobCAM_swaps,
                    )
                    current_xrpl_block = self.simulate_normal_users_txs(
                        xrpl_amm,
                        current_xrpl_block,
                        time_step,
                        action,
                        amount,
                        xrpl_sp,
                        swapper=bob_swaps,
                    )
                    current_uniswap_block = self.simulate_normal_users_txs(
                        uniswap_amm,
                        current_uniswap_block,
                        time_step,
                        action,
                        amount,
                        uniswap_sp,
                        sp_B=uniswap_sp_B,
                    )

                # ARBITRAGE TRANSACTIONS
                for arb in range(arbitrageurs):
                    current_xrplCAM_block = self.check_bid(
                        max_bid,
                        time_step,
                        current_slot_time_interval,
                        xrplCAM,
                        current_xrplCAM_block,
                        external_prices[time_step],
                        xrpl_fees,
                        xrplCAM_arbits_swaps_obj[arb],
                        xrplCAM_arbits_bids_obj[arb],
                        safe_profit_margin,
                        new_24h_start + one_day,
                        worst_case=False,
                    )

                    if with_cases:
                        current_xrpl_block = self.check_bid(
                            max_bid,
                            time_step,
                            xrpl_current_slot_time_interval,
                            xrpl_amm,
                            current_xrpl_block,
                            external_prices[time_step],
                            xrpl_fees,
                            xrpl_arbits_swaps_obj[arb],
                            xrpl_arbits_bids_obj[arb],
                            safe_profit_margin,
                            xrpl_new_24h_start + one_day,
                            worst_case=True,
                        )

                    current_xrplCAM_block = self.check_arbit_opportunity(
                        time_step,
                        xrplCAM,
                        current_xrplCAM_block,
                        external_prices[time_step],
                        xrpl_fees,
                        safe_profit_margin,
                        swapper=xrplCAM_arbits_swaps_obj[arb],
                    )
                    current_xrpl_block = self.check_arbit_opportunity(
                        time_step,
                        xrpl_amm,
                        current_xrpl_block,
                        external_prices[time_step],
                        xrpl_fees,
                        safe_profit_margin,
                        swapper=xrpl_arbits_swaps_obj[arb],
                    )
                    current_uniswap_block = self.check_arbit_opportunity(
                        time_step,
                        uniswap_amm,
                        current_uniswap_block,
                        external_prices[time_step],
                        eth_fees,
                        safe_profit_margin,
                    )

                # if not worst_case and time_step and time_step % one_day == 0:
                if time_step and time_step % one_day == 0:
                    if len(xrplCAM_0fee_profits_total) == start_simulation_at_day:
                        xrplCAM_0fee_profits_total.append(sum(xrplCAM_profits))
                    else:
                        xrplCAM_0fee_profits_total.append(
                            sum(xrplCAM_profits[start_index:])
                        )
                    weights = [
                        0.5**i
                        for i in reversed(range(len(xrplCAM_0fee_profits_total)))
                    ]
                    max_bid = np.average(xrplCAM_0fee_profits_total, weights=weights)
                    start_index = len(xrplCAM_profits)

            bids_profit["B_adjusted"] = bids_profit["LPTokens"] * self.LPT_price(
                xrplCAM.assets["LPTokens"],
                xrplCAM.assets["A"],
                xrplCAM.assets["B"],
                xrplCAM.spot_price("A", "B"),
                1,
            )

            xrpl_bids_profit["B_adjusted"] = xrpl_bids_profit[
                "LPTokens"
            ] * self.LPT_price(
                xrpl_amm.assets["LPTokens"],
                xrpl_amm.assets["A"],
                xrpl_amm.assets["B"],
                xrpl_amm.spot_price("A", "B"),
                1,
            )

            p_CAM = xrplCAM.spot_price("A", "B") / initial_A_price - 1
            p_xrpl = xrpl_amm.spot_price("A", "B") / initial_A_price - 1
            p_uniswap = uniswap_amm.spot_price("A", "B") / initial_A_price - 1

            impermanent_losses["xrplCAM"].append(
                self.compute_impermanent_loss(
                    arbitrageurs,
                    initial_A_reserve,
                    initial_B_reserve,
                    xrplCAM.assets["A"],
                    xrplCAM.assets["B"],
                    xrplCAM_sp,
                    external_prices[-1],
                    xrplCAM_sps[0],
                    p_CAM,
                    bids_profit["B_adjusted"] + xrplCAM_tfees,
                )
            )
            impermanent_losses["xrpl"].append(
                self.compute_impermanent_loss(
                    arbitrageurs,
                    initial_A_reserve,
                    initial_B_reserve,
                    xrpl_amm.assets["A"],
                    xrpl_amm.assets["B"],
                    xrpl_sp,
                    external_prices[-1],
                    xrpl_sps[0],
                    p_xrpl,
                    xrpl_bids_profit["B_adjusted"] + xrpl_tfees,
                )
            )
            impermanent_losses["uniswap"].append(
                self.compute_impermanent_loss(
                    arbitrageurs,
                    initial_A_reserve,
                    initial_B_reserve,
                    uniswap_amm.asset_A_amount,
                    uniswap_amm.asset_B_amount,
                    uniswap_sp,
                    external_prices[-1],
                    uniswap_sps[0],
                    p_uniswap,
                    uniswap_tfees,
                )
            )

            xrpl_profits_total.append(xrpl_profits)
            xrplCAM_profits_total.append(xrplCAM_profits)
            uniswap_profits_total.append(uniswap_profits)
            xrpl_arbit_txs_total.append(xrpl_arbit_txs)
            xrplCAM_arbit_txs_total.append(xrplCAM_arbit_txs)
            uniswap_arbit_txs_total.append(uniswap_arbit_txs)

            xrplCAM_slippages_total.append(xrplCAM_slippages)
            xrpl_slippages_total.append(xrpl_slippages)
            uniswap_slippages_total.append(uniswap_slippages)

            xrplCAM_unrealized_tx_total.append(xrplCAM_unrealized_tx)
            xrpl_unrealized_tx_total.append(xrpl_unrealized_tx)
            uniswap_unrealized_tx_total.append(uniswap_unrealized_tx)

            auction_slot_price_total.append(auction_slot_price)
            xrpl_auction_slot_price_total.append(xrpl_auction_slot_price)

            xrpl_sps_total.append([iteration, xrpl_sps])
            xrplCAM_sps_total.append([iteration, xrplCAM_sps])
            uniswap_sps_total.append([iteration, uniswap_sps])

            bids_profit_total.append(bids_profit)
            xrpl_bids_profit_total.append(xrpl_bids_profit)

            slot_holders_txs.append(current_slot_holders_txs)
            xrpl_slot_holders_txs.append(xrpl_current_slot_holders_txs)

            xrplCAM_trading_volumes.append(xrplCAM_current_trading_volume)
            xrpl_trading_volumes.append(xrpl_current_trading_volume)
            uniswap_trading_volumes.append(uniswap_current_trading_volume)

            xrplCAM_tfees_total.append(xrplCAM_tfees)
            xrpl_tfees_total.append(xrpl_tfees)
            uniswap_tfees_total.append(uniswap_tfees)

            bids_refunds_total.append(bids_refunds)
            xrpl_bids_refunds_total.append(bids_refunds)

            xrplCAM_ArbProfits_advantage = self.compute_ArbitrageursProfits_advantage(
                xrplCAM_profits_total[-1],
                uniswap_profits_total[-1],
                xrplCAM_ArbProfits_advantage,
            )
            xrpl_ArbProfits_advantage = self.compute_ArbitrageursProfits_advantage(
                xrpl_profits_total[-1],
                uniswap_profits_total[-1],
                xrpl_ArbProfits_advantage,
            )
            xrpls_CAM_ArbProfits_advantage = self.compute_ArbitrageursProfits_advantage(
                xrplCAM_profits_total[-1],
                xrpl_profits_total[-1],
                xrpls_CAM_ArbProfits_advantage,
            )

            xrplCAM_PriceGap_advantage = self.compute_PriceGap_advantage(
                external_prices, xrplCAM_sps, uniswap_sps, xrplCAM_PriceGap_advantage
            )
            xrpl_PriceGap_advantage = self.compute_PriceGap_advantage(
                external_prices, xrpl_sps, uniswap_sps, xrpl_PriceGap_advantage
            )
            xrpls_CAM_PriceGap_advantage = self.compute_PriceGap_advantage(
                external_prices, xrplCAM_sps, xrpl_sps, xrpls_CAM_PriceGap_advantage
            )

            xrplCAM_LP_returns_advantage = self.compute_LP_returns_advantage(
                xrplCAM_tfees + bids_profit["B_adjusted"],
                uniswap_tfees,
                xrplCAM_LP_returns_advantage,
            )
            xrpl_LP_returns_advantage = self.compute_LP_returns_advantage(
                xrpl_tfees, uniswap_tfees, xrpl_LP_returns_advantage
            )
            xrpls_CAM_LP_returns_advantage = self.compute_LP_returns_advantage(
                xrplCAM_tfees + bids_profit["B_adjusted"],
                xrpl_tfees,
                xrpls_CAM_LP_returns_advantage,
            )

        print("End of simulation.")
        return {
            "xrplCAM_profits_total": xrplCAM_profits_total,
            "xrpl_profits_total": xrpl_profits_total,
            "uniswap_profits_total": uniswap_profits_total,
            "xrplCAM_arbit_txs_total": xrplCAM_arbit_txs_total,
            "xrpl_arbit_txs_total": xrpl_arbit_txs_total,
            "uniswap_arbit_txs_total": uniswap_arbit_txs_total,
            "xrplCAM_sps_total": xrplCAM_sps_total,
            "xrpl_sps_total": xrpl_sps_total,
            "uniswap_sps_total": uniswap_sps_total,
            "xrplCAM_slippages_total": xrplCAM_slippages_total,
            "xrpl_slippages_total": xrpl_slippages_total,
            "uniswap_slippages": uniswap_slippages_total,
            "xrplCAM_unrealized_tx_total": xrplCAM_unrealized_tx_total,
            "xrpl_unrealized_tx_total": xrpl_unrealized_tx_total,
            "uniswap_unrealized_tx_total": uniswap_unrealized_tx_total,
            "xrplCAM_tfees_total": xrplCAM_tfees_total,
            "xrpl_tfees_total": xrpl_tfees_total,
            "uniswap_tfees_total": uniswap_tfees_total,
            "xrplCAM_trading_volumes": xrplCAM_trading_volumes,
            "xrpl_trading_volumes": xrpl_trading_volumes,
            "uniswap_trading_volumes": uniswap_trading_volumes,
            "auction_slot_price_total": auction_slot_price_total,
            "bids_profit_total": bids_profit_total,
            "xrpl_bids_profit_total": xrpl_bids_profit_total,
            "impermanent_losses": impermanent_losses,
            "price_impacts": price_impacts,
            "xrplCAM_ArbProfits_advantage": round(
                xrplCAM_ArbProfits_advantage / iterations * 100
            ),
            "xrpl_ArbProfits_advantage": round(
                xrpl_ArbProfits_advantage / iterations * 100
            ),
            "xrpls_CAM_ArbProfits_advantage": round(
                xrpls_CAM_ArbProfits_advantage / iterations * 100
            ),
            "xrplCAM_PriceGap_advantage": round(
                xrplCAM_PriceGap_advantage / iterations * 100
            ),
            "xrpl_PriceGap_advantage": round(
                xrpl_PriceGap_advantage / iterations * 100
            ),
            "xrpls_CAM_PriceGap_advantage": round(
                xrpls_CAM_PriceGap_advantage / iterations * 100
            ),
            "xrplCAM_LP_returns_advantage": round(
                xrplCAM_LP_returns_advantage / iterations * 100
            ),
            "xrpl_LP_returns_advantage": round(
                xrpl_LP_returns_advantage / iterations * 100
            ),
            "xrpls_CAM_LP_returns_advantage": round(
                xrpls_CAM_LP_returns_advantage / iterations * 100
            ),
            "bids_refunds_total": bids_refunds_total,
            "slot_holders_txs": slot_holders_txs,
            "xrpl_slot_holders_txs": xrpl_slot_holders_txs,
        }
